use alloy::primitives::Address;
use foundry_block_explorers::contract::ContractMetadata;
use serde::{Deserialize, Serialize};
use t_lib::log::{Level, instrument};

use crate::{
    error::Error,
    fetch::{Fetch, Param, etherscan::client::Etherscan},
};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Params {
    pub contract: Address,
}

impl Param for Params {
    type Err = Error;
    type Ret = ContractMetadata;
}

impl Fetch<Params> for Etherscan {
    type Err = <Params as Param>::Err;
    type Ret = <Params as Param>::Ret;

    #[instrument(level = Level::TRACE, skip_all, err, fields(?params))]
    async fn fetch(&mut self, params: Params) -> Result<Self::Ret, Self::Err> {
        let Params { contract } = params;
        let metadata = self.contract_source_code(contract).await?;
        Ok(metadata)
    }
}

#[cfg(test)]
mod tests {
    use std::path::Path;

    use alloy::primitives::address;
    use insta::assert_debug_snapshot;
    use nill::{Nil, nil};

    use super::*;
    use crate::fetch::etherscan::EtherscanFetch;

    const DOWNLOAD_DIR: &str = concat!(env!("TSRV_SHARE_DIR"), "/contract/download");

    const PROXY_SWAP_V2_IMPL: Address = address!("0xb8Bb1FFb166d2536E92749eb1Aaf8Cac07456281");
    const PROXY_SWAP_V2_ROUTER: Address = address!("0x5efc784D444126ECc05f22c49FF3FBD7D9F4868a");

    #[ignore]
    #[tokio::test]
    async fn test_download_proxy_swap_v2_impl() -> Result<Nil, Error> {
        let param = Params { contract: PROXY_SWAP_V2_IMPL };
        let metadata = param.fetch().await?;
        let source_tree = metadata.source_tree();
        let dir = format!("{DOWNLOAD_DIR}/{PROXY_SWAP_V2_IMPL}");
        source_tree.write_to(&Path::new(&dir))?;
        Ok(nil)
    }

    #[ignore]
    #[tokio::test]
    async fn test_download_proxy_swap_v2_router() -> Result<Nil, Error> {
        let param = Params { contract: PROXY_SWAP_V2_ROUTER };
        let metadata = param.fetch().await?;
        let source_tree = metadata.source_tree();
        let dir = format!("{DOWNLOAD_DIR}/{PROXY_SWAP_V2_ROUTER}");
        source_tree.write_to(&Path::new(&dir))?;
        Ok(nil)
    }

    #[tokio::test]
    async fn test_get_contract_source_code() -> Result<Nil, Error> {
        let param = Params { contract: PROXY_SWAP_V2_ROUTER };
        let metadata = param.fetch().await?;
        let json = serde_json::to_string(&metadata)?;
        assert_debug_snapshot!(json, @r#""[{\"SourceCode\":{\"language\":\"Solidity\",\"sources\":{\"src/interfaces/IAggregator.sol\":{\"content\":\"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAggregator {\\n    /// @notice Thrown when executing swap with an expired deadline\\n    error TransactionDeadlinePassed();\\n\\n    /// @notice Thrown when amount specified is zero\\n    error ZeroAmount();\\n\\n    /// @notice Thrown when the input token ETH but msg.value == 0\\n    error ZeroNativeToken();\\n\\n    /// @notice Thrown when the input token is not ETH but msg.value > 0\\n    error NonZeroNativeToken();\\n\\n    /// @notice Thrown when the specified ETH is not equal to the actual received amount\\n    error AmountMisMatch();\\n\\n    /// @notice Thrown when the routes amount length does not match the routes length\\n    error RoutesLengthNotMatchRoutesAmountLength();\\n\\n    /// @notice Thrown when the input token specified does not match the from token in the route[*][0].fromToken\\n    error InputTokenNotMatchRouteFromToken();\\n\\n    /// @notice Thrown when the sum of path weight is over 10000 i.e. 100%\\n    error PathWeightInvalid();\\n\\n    /// @notice Thrown when the output token amount is less than the minimum return amount\\n    error MinReturnNotReached();\\n\\n    /// @notice Thrown when sweeping tokens but specified amount is not available\\n    error InsufficientToken();\\n\\n    /// @notice Thrown when the adapter specified by calldata is not whitelisted\\n    error AdapterNotWhitelisted();\\n\\n    /// @param intputToken The token the trader will pay, use address(0) for ETH\\n    /// @param outputToken The output token the trader expect to receive, use address(0) for ETH\\n    /// @param minOutputAmount The minimum amount of output tokens that must be received for the transaction not to revert\\n    /// @param deadline The time by which the transaction must be included to effect the swap\\n    struct BaseExactInRequest {\\n        address inputToken;\\n        address outputToken;\\n        uint256 minOutputAmount;\\n        uint256 deadline;\\n    }\\n\\n    struct RouterPath {\\n        // each hop could have multiple forks (each fork could be a different pool)\\n        // it specifies the adapter address that should be used for interacting with the pool\\n        // however, some commonly used protocols like pancake, uniswap will be supported inlined\\n        // so the adapter address will be special value, check PathAdapterHelper.sol for more details\\n        uint256[] mixAdapters;\\n        // it specifies where should the input token should be sent to while interacting with the pool\\n        address[] assetTo;\\n        // it specifies the required information for interacting with each pool which includes\\n        // - reverse flag: by default it should be zero for one swap, but if it's 1 then it should be swapped in reverse order\\n        // - weight: it's the percentage of input token that should be used for swap, 10000 means 100%, excess token from division will be given to last iteration\\n        // - pool address: the pool address where the swap should happen\\n        uint256[] rawData;\\n        // it specifies the extra data that should be passed to the pool while interacting with it\\n        bytes[] extraData;\\n        // it specifies the input token for current hop (multiple forks will share the same input token)\\n        address fromToken;\\n    }\\n\\n    /// @notice Wrap the ETH to WETH or unwrap WETH to the ETH, if it's wrap then the amount should match the msg value\\n    /// @param orderId The unique order id which can be used to track the order through the whole process\\n    /// @param amount The amount of ETH/WETH to wrap/unwrap\\n    /// @param isWrap True if it's wrap, false if it's unwrap\\n    /// @param feeConfig The fee configuration for the transaction, usually charged by the 3rd party integrator, 0 means no fee\\n    /// @return outputAmtReceived What the swapper get as output amount\\n    function swapWrap(uint256 orderId, uint256 amount, bool isWrap, uint256 feeConfig)\\n        external\\n        payable\\n        returns (uint256 outputAmtReceived);\\n\\n    /// @notice Swap exact input tokens for as much output tokens as possible, along the route determined by the path.\\n    /// @notice Before calling this function, the caller must approve the contract to spend the input token\\n    /// @param orderId The unique order id which can be used to track the order through the whole process\\n    /// @param request The basic request information for the exact-in swap\\n    /// @param routesAmount It specifies the exact amount of input token that trader wants to trades in for each route\\n    /// @param routes The detailed information for all hops, it's two demensional array since each route could have multiple hops\\n    /// @param feeConfig The fee configuration for the transaction, usually charged by the 3rd party integrator, 0 means no fee\\n    /// @return outputAmtReceived What the swapper get as output amount\\n    function swapExactIn(\\n        uint256 orderId,\\n        BaseExactInRequest calldata request,\\n        uint256[] calldata routesAmount,\\n        RouterPath[][] calldata routes,\\n        uint256 feeConfig\\n    ) external payable returns (uint256 outputAmtReceived);\\n\\n    /// @notice whitelist the adapter to the aggregator, any external adapter must first be whitelisted\\n    /// @notice before they can interact with the aggregator\\n    /// @param adapter The address of the adapter\\n    /// @param whitelisted True if the adapter should be whitelisted, false if it should be unwhitelisted\\n    function whitelistAdapter(address adapter, bool whitelisted) external;\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/interfaces/IHooks.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IHooks {\\n    function getHooksRegistrationBitmap() external view returns (uint16);\\n}\\n\"},\"lib/infinity-periphery/src/interfaces/external/IWETH9.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title IWETH9\\n/// @notice Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\"},\"src/libraries/PathAdapterHelper.sol\":{\"content\":\"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title PathAdapterHelper\\n/// @notice each adapter is a 256-bit integer, which is used to signal the behavior of the adapter:\\n///     here is the layout of the adapter and the meaning of each part:\\n///     |  254 ~ 255                        | 249 ~ 251    | 0 ~ 160\\n///     |  whether wrap/unwrap input token  | adapter type | address of the adapte\\nlibrary PathAdapterHelper {\\n    /// @notice used to signal that whether the input token of current fork should be wrapped/unwrapped\\n    /// @dev it's the highest two bits of the adapter\\n    uint256 public constant INPUT_WRAP_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 public constant INPUT_UNWRAP_MASK = 0x4000000000000000000000000000000000000000000000000000000000000000;\\n\\n    function shouldInputWrapped(uint256 adapter) internal pure returns (bool) {\\n        return (adapter & INPUT_WRAP_MASK) != 0;\\n    }\\n\\n    function shouldInputUnwrapped(uint256 adapter) internal pure returns (bool) {\\n        return (adapter & INPUT_UNWRAP_MASK) != 0;\\n    }\\n\\n    /// @dev the following constants are used to signal those inlined adapters\\n\\n    /// @notice used to signal that the interface of the pool should conform to the Uniswap V2\\n    uint256 public constant UNIV2_ADAPTER_MASK = 0x0800000000000000000000000000000000000000000000000000000000000000;\\n\\n    /// @notice used to signal that the interface of the pool should conform to the PancakeSwap V2\\n    uint256 public constant PCSV2_ADAPTER_MASK = 0x0400000000000000000000000000000000000000000000000000000000000000;\\n\\n    /// @notice used to signal that the interface of the pool should conform to the Uniswap V3\\n    ///         for example Uniswap V3 or PancakeSwap V3\\n    uint256 public constant UNIV3_STYLED_ADAPTER_MASK =\\n        0x0200000000000000000000000000000000000000000000000000000000000000;\\n\\n    function isUniV2Adapter(uint256 adapter) internal pure returns (bool) {\\n        return (adapter & UNIV2_ADAPTER_MASK) != 0;\\n    }\\n\\n    function isPcsV2Adapter(uint256 adapter) internal pure returns (bool) {\\n        return (adapter & PCSV2_ADAPTER_MASK) != 0;\\n    }\\n\\n    function isUniV3StyledAdapter(uint256 adapter) internal pure returns (bool) {\\n        return (adapter & UNIV3_STYLED_ADAPTER_MASK) != 0;\\n    }\\n}\\n\"},\"src/interfaces/IUniV3StyledSwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice Any contract that calls IUniV3StyledPool#swap must implement this interface\\ninterface IUniV3StyledSwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniV3StyledPool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\\n\\n    /// @notice PancakeSwap V3 pool has basic the same callback as Uniswap V3 pool\\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\\n * old one. This can help prevent common mistakes, such as transfers of ownership to\\n * incorrect accounts, or to contracts that are unable to interact with the\\n * permission system.\\n *\\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        if (pendingOwner() != sender) {\\n            revert OwnableUnauthorizedAccount(sender);\\n        }\\n        _transferOwnership(sender);\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/interfaces/IERC20Minimal.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Minimal ERC20 interface for PancakeSwap\\n/// @notice Contains a subset of the full ERC20 interface that is used in PancakeSwap V3\\ninterface IERC20Minimal {\\n    /// @notice Returns the balance of a token\\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\\n    /// @return The number of tokens held by the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\\n    /// @param recipient The account that will receive the amount transferred\\n    /// @param amount The number of tokens to send from the sender to the recipient\\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the current allowance given to a spender by an owner\\n    /// @param owner The account of the token owner\\n    /// @param spender The account of the token spender\\n    /// @return The current allowance granted by `owner` to `spender`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\\n    /// @param amount The amount of tokens allowed to be used by `spender`\\n    /// @return Returns true for a successful approval, false for unsuccessful\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\\n    /// @param sender The account from which the transfer will be initiated\\n    /// @param recipient The recipient of the transfer\\n    /// @param amount The amount of the transfer\\n    /// @return Returns true for a successful transfer, false for unsuccessful\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\\n    /// @param value The amount of tokens that were transferred\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\\n    /// @param owner The account that approved spending of its tokens\\n    /// @param spender The account for which the spending allowance was modified\\n    /// @param value The new allowance from the owner to the spender\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"src/libraries/FeeHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.0;\\n\\nimport {FullMath} from \\\"infinity-core/src/pool-cl/libraries/FullMath.sol\\\";\\n\\n/// @notice This library is used to handle fee related logic\\nlibrary FeeHelper {\\n    /// @notice Throw when the fee percentage is invalid\\n    error InvalidFeePercentage();\\n\\n    /// @notice Throw when the fee recipient is invalid\\n    error InvalidFeeRecipient();\\n\\n    //   The fee configuration is stored in a single bytes32 variable in the following format:\\n    //   [0 - 160[: fee recipient address (20 bytes)\\n    //   [240 - 256[: fee percentage (2 bytes), at max 10000 i.e. 100%\\n    uint256 public constant MAX_FEE = 10000;\\n\\n    /// @notice Parse the fee configuration and return the fee recipient and fee amount\\n    /// @param feeConfig The fee configuration provided by the caller\\n    /// @param amount The amount of token that the fee should be charged on top of, for aggregators it should be output amount\\n    function getFeeInfo(uint256 feeConfig, uint256 amount)\\n        internal\\n        pure\\n        returns (uint256 feeAmount, address feeRecipient)\\n    {\\n        uint256 feePercentage = feeConfig >> 240;\\n        if (feePercentage > MAX_FEE || feePercentage == 0) {\\n            revert InvalidFeePercentage();\\n        }\\n\\n        /// @notice rounding up for consistency, following pancake infinity-core\\n        feeAmount = FullMath.mulDivRoundingUp(amount, feePercentage, MAX_FEE);\\n\\n        feeRecipient = address(uint160(feeConfig));\\n        if (feeRecipient == address(0)) {\\n            revert InvalidFeeRecipient();\\n        }\\n    }\\n\\n    /// @notice Build the fee configuration from the fee percentage and fee recipient address\\n    /// @dev this function is only used in test, it's not expected to be used in production\\n    /// @param feePercentage The fee percentage to be charged on top of the amount (max 10000 i.e. 100%)\\n    /// @param feeRecipient The address of the fee recipient\\n    function buildFeeConfig(uint256 feePercentage, address feeRecipient) internal pure returns (uint256 feeConfig) {\\n        if (feePercentage > MAX_FEE) {\\n            revert InvalidFeePercentage();\\n        }\\n\\n        if (feePercentage == 0 || feeRecipient == address(0)) {\\n            return 0;\\n        }\\n\\n        feeConfig = uint256(uint160(feeRecipient)) | (feePercentage << 240);\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"},\"src/base/PausableOwner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Ownable2Step} from \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\n\\nabstract contract PausableOwner is Pausable, Ownable2Step {\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/libraries/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.0;\\n\\n/// @title Safe casting methods\\n/// @notice Contains methods for safely casting between types\\nlibrary SafeCast {\\n    error SafeCastOverflow();\\n\\n    function _revertOverflow() private pure {\\n        assembly (\\\"memory-safe\\\") {\\n            // Store the function selector of `SafeCastOverflow()`.\\n            mstore(0x00, 0x93dafdf1)\\n            // Revert with (offset, size).\\n            revert(0x1c, 0x04)\\n        }\\n    }\\n\\n    /// @notice Cast a uint256 to a uint160, revert on overflow\\n    /// @param x The uint256 to be downcasted\\n    /// @return y The downcasted integer, now type uint160\\n    function toUint160(uint256 x) internal pure returns (uint160 y) {\\n        y = uint160(x);\\n        if (y != x) _revertOverflow();\\n    }\\n\\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\\n    /// @param x The int256 to be downcasted\\n    /// @return y The downcasted integer, now type int128\\n    function toInt128(int256 x) internal pure returns (int128 y) {\\n        y = int128(x);\\n        if (y != x) _revertOverflow();\\n    }\\n\\n    /// @notice Cast a uint256 to a int256, revert on overflow\\n    /// @param x The uint256 to be casted\\n    /// @return y The casted integer, now type int256\\n    function toInt256(uint256 x) internal pure returns (int256 y) {\\n        y = int256(x);\\n        if (y < 0) _revertOverflow();\\n    }\\n\\n    /// @notice Cast a int256 to a uint256, revert on overflow\\n    /// @param x The int256 to be casted\\n    /// @return y The casted integer, now type uint256\\n    function toUint256(int256 x) internal pure returns (uint256 y) {\\n        if (x < 0) _revertOverflow();\\n        y = uint256(x);\\n    }\\n\\n    /// @notice Cast a uint256 to a int128, revert on overflow\\n    /// @param x The uint256 to be downcasted\\n    /// @return The downcasted integer, now type int128\\n    function toInt128(uint256 x) internal pure returns (int128) {\\n        if (x >= 1 << 127) _revertOverflow();\\n        return int128(int256(x));\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/types/PoolId.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {PoolKey} from \\\"./PoolKey.sol\\\";\\n\\ntype PoolId is bytes32;\\n\\n/// @notice Library for computing the ID of a pool\\nlibrary PoolIdLibrary {\\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId poolId) {\\n        assembly (\\\"memory-safe\\\") {\\n            // 0xc0 represents the total size of the poolKey struct (6 slots of 32 bytes)\\n            poolId := keccak256(poolKey, 0xc0)\\n        }\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/types/PoolKey.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Currency} from \\\"./Currency.sol\\\";\\nimport {IPoolManager} from \\\"../interfaces/IPoolManager.sol\\\";\\nimport {IHooks} from \\\"../interfaces/IHooks.sol\\\";\\nimport {PoolIdLibrary} from \\\"./PoolId.sol\\\";\\n\\nusing PoolIdLibrary for PoolKey global;\\n\\n/// @notice Returns the key for identifying a pool\\nstruct PoolKey {\\n    /// @notice The lower currency of the pool, sorted numerically\\n    Currency currency0;\\n    /// @notice The higher currency of the pool, sorted numerically\\n    Currency currency1;\\n    /// @notice The hooks of the pool, won't have a general interface because hooks interface vary on pool type\\n    IHooks hooks;\\n    /// @notice The pool manager of the pool\\n    IPoolManager poolManager;\\n    /// @notice The pool lp fee, capped at 1_000_000. If the pool has a dynamic fee then it must be exactly equal to 0x800000\\n    uint24 fee;\\n    /// @notice Hooks callback and pool specific parameters, i.e. tickSpacing for CL, binStep for bin\\n    bytes32 parameters;\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/types/Currency.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Minimal} from \\\"../interfaces/IERC20Minimal.sol\\\";\\nimport {CustomRevert} from \\\"../libraries/CustomRevert.sol\\\";\\n\\ntype Currency is address;\\n\\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\\nusing CurrencyLibrary for Currency global;\\n\\nfunction equals(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) == Currency.unwrap(other);\\n}\\n\\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) > Currency.unwrap(other);\\n}\\n\\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) < Currency.unwrap(other);\\n}\\n\\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\\n}\\n\\n/// @title CurrencyLibrary\\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\\nlibrary CurrencyLibrary {\\n    using CurrencyLibrary for Currency;\\n\\n    /// @notice Additional context for ERC-7751 wrapped error when a native transfer fails\\n    error NativeTransferFailed();\\n\\n    /// @notice Additional context for ERC-7751 wrapped error when an ERC20 transfer fails\\n    error ERC20TransferFailed();\\n\\n    /// @notice A constant to represent the native currency\\n    Currency public constant NATIVE = Currency.wrap(address(0));\\n\\n    function transfer(Currency currency, address to, uint256 amount) internal {\\n        // altered from https://github.com/transmissions11/solmate/blob/44a9963d4c78111f77caa0e65d677b8b46d6f2e6/src/utils/SafeTransferLib.sol\\n        // modified custom error selectors\\n\\n        bool success;\\n        if (currency.isNative()) {\\n            assembly (\\\"memory-safe\\\") {\\n                // Transfer the ETH and revert if it fails.\\n                success := call(gas(), to, amount, 0, 0, 0, 0)\\n            }\\n            // revert with NativeTransferFailed, containing the bubbled up error as an argument\\n            if (!success) CustomRevert.bubbleUpAndRevertWith(to, bytes4(0), NativeTransferFailed.selector);\\n        } else {\\n            assembly (\\\"memory-safe\\\") {\\n                // Get a pointer to some free memory.\\n                let fmp := mload(0x40)\\n\\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\\n                mstore(fmp, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n                mstore(add(fmp, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n                mstore(add(fmp, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n                success :=\\n                    and(\\n                        // Set success to whether the call reverted, if not we check it either\\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                        // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                        // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                        // Counterintuitively, this call must be positioned second to the or() call in the\\n                        // surrounding and() call or else returndatasize() will be zero during the computation.\\n                        call(gas(), currency, 0, fmp, 68, 0, 32)\\n                    )\\n\\n                // Now clean the memory we used\\n                mstore(fmp, 0) // 4 byte `selector` and 28 bytes of `to` were stored here\\n                mstore(add(fmp, 0x20), 0) // 4 bytes of `to` and 28 bytes of `amount` were stored here\\n                mstore(add(fmp, 0x40), 0) // 4 bytes of `amount` were stored here\\n            }\\n            // revert with ERC20TransferFailed, containing the bubbled up error as an argument\\n            if (!success) {\\n                CustomRevert.bubbleUpAndRevertWith(\\n                    Currency.unwrap(currency), IERC20Minimal.transfer.selector, ERC20TransferFailed.selector\\n                );\\n            }\\n        }\\n    }\\n\\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return address(this).balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\\n        }\\n    }\\n\\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\\n        if (currency.isNative()) {\\n            return owner.balance;\\n        } else {\\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\\n        }\\n    }\\n\\n    function isNative(Currency currency) internal pure returns (bool) {\\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\\n    }\\n\\n    function toId(Currency currency) internal pure returns (uint256) {\\n        return uint160(Currency.unwrap(currency));\\n    }\\n\\n    function fromId(uint256 id) internal pure returns (Currency) {\\n        return Currency.wrap(address(uint160(id)));\\n    }\\n}\\n\"},\"src/Aggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.26;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IVault} from \\\"infinity-core/src/interfaces/IVault.sol\\\";\\nimport {IWETH9} from \\\"infinity-periphery/src/interfaces/external/IWETH9.sol\\\";\\nimport {ReentrancyLock} from \\\"infinity-periphery/src/base/ReentrancyLock.sol\\\";\\n\\nimport {NativeWrapper} from \\\"./base/NativeWrapper.sol\\\";\\nimport {ImmutableState} from \\\"./base/ImmutableState.sol\\\";\\nimport {PausableOwner} from \\\"./base/PausableOwner.sol\\\";\\nimport {FeeHelper} from \\\"./libraries/FeeHelper.sol\\\";\\nimport {IAdapter} from \\\"./interfaces/IAdapter.sol\\\";\\nimport {IAggregator} from \\\"./interfaces/IAggregator.sol\\\";\\nimport {CommonUtils} from \\\"./libraries/CommonUtils.sol\\\";\\nimport {UniV2StyledAdapter} from \\\"./adapters/UniV2StyledAdapter.sol\\\";\\nimport {UniV3StyledAdapter} from \\\"./adapters/UniV3StyledAdapter.sol\\\";\\nimport {PathRawDataHelper} from \\\"./libraries/PathRawDataHelper.sol\\\";\\nimport {PathAdapterHelper} from \\\"./libraries/PathAdapterHelper.sol\\\";\\nimport {Payment} from \\\"./base/Payment.sol\\\";\\n\\ncontract Aggregator is\\n    IAggregator,\\n    Payment,\\n    NativeWrapper,\\n    PausableOwner,\\n    ReentrancyLock,\\n    UniV2StyledAdapter,\\n    UniV3StyledAdapter\\n{\\n    using CommonUtils for *;\\n    using PathRawDataHelper for uint256;\\n    using PathAdapterHelper for uint256;\\n    using FeeHelper for uint256;\\n\\n    /// @notice emit event when a swap order is created, this can be used to track the order\\n    event SwapOrderId(uint256 id);\\n\\n    /// @notice emit event when a fee is charged\\n    event FeeRecord(uint256 feeAmount, address recipient);\\n\\n    /// @notice emit event when a swap order is executed successfully\\n    event OrderRecord(\\n        address inputToken, address outputToken, address sender, uint256 inputAmount, uint256 outputAmount\\n    );\\n\\n    /// @notice emit event when an adapter is whitelisted / unwhitelisted\\n    event AdapterWhitelisted(address adapter, bool whitelisted);\\n\\n    /// @notice exteranl adapters are by default not allowed to be used in the aggregator unless whitelisted\\n    mapping(address => bool) public isAdapterWhitelisted;\\n\\n    constructor(\\n        address _uniV3Factory,\\n        bytes32 _uniV3PoolInitCodeHash,\\n        address _pcsV3Deployer,\\n        bytes32 _pcsV3PoolInitCodeHash,\\n        IWETH9 _weth9\\n    )\\n        ImmutableState(_uniV3Factory, _uniV3PoolInitCodeHash, _pcsV3Deployer, _pcsV3PoolInitCodeHash)\\n        NativeWrapper(_weth9)\\n        Ownable(msg.sender)\\n    {}\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        if (block.timestamp > deadline) revert TransactionDeadlinePassed();\\n        _;\\n    }\\n\\n    /// @inheritdoc IAggregator\\n    function swapWrap(uint256 orderId, uint256 amount, bool isWrap, uint256 feeConfig)\\n        external\\n        payable\\n        isNotLocked\\n        whenNotPaused\\n        returns (uint256 outputAmtReceived)\\n    {\\n        emit SwapOrderId(orderId);\\n\\n        if (amount == 0) {\\n            revert ZeroAmount();\\n        }\\n\\n        address inputToken;\\n        address outputToken;\\n        if (isWrap) {\\n            if (msg.value == 0) revert ZeroNativeToken();\\n            if (msg.value != amount) revert AmountMisMatch();\\n\\n            inputToken = CommonUtils.ETH;\\n            outputToken = address(WETH9);\\n\\n            _wrap(amount);\\n        } else {\\n            if (msg.value > 0) revert NonZeroNativeToken();\\n\\n            inputToken = address(WETH9);\\n            outputToken = CommonUtils.ETH;\\n\\n            _transferInternal(msg.sender, address(this), inputToken, amount);\\n            _unwrap(amount);\\n        }\\n\\n        outputAmtReceived = amount;\\n        if (feeConfig != 0) {\\n            (uint256 feeAmount, address feeRecipient) = feeConfig.getFeeInfo(outputAmtReceived);\\n            outputAmtReceived -= feeAmount;\\n            _transferInternal(address(this), feeRecipient, outputToken, feeAmount);\\n            emit FeeRecord(feeAmount, feeRecipient);\\n        }\\n        _transferInternal(address(this), msg.sender, outputToken, outputAmtReceived);\\n\\n        emit OrderRecord(inputToken, outputToken, msg.sender, amount, outputAmtReceived);\\n    }\\n\\n    /// @inheritdoc IAggregator\\n    function swapExactIn(\\n        uint256 orderId,\\n        BaseExactInRequest calldata request,\\n        uint256[] calldata routesAmount,\\n        RouterPath[][] calldata routes,\\n        uint256 feeConfig\\n    ) external payable checkDeadline(request.deadline) isNotLocked whenNotPaused returns (uint256 outputAmtReceived) {\\n        emit SwapOrderId(orderId);\\n\\n        address inputToken = request.inputToken;\\n        address payer = inputToken == CommonUtils.ETH ? address(this) : msg.sender;\\n        uint256 totalInputTokenAmount;\\n        {\\n            if (inputToken == CommonUtils.ETH && msg.value == 0) {\\n                revert ZeroNativeToken();\\n            }\\n\\n            if (inputToken != CommonUtils.ETH && msg.value > 0) {\\n                revert NonZeroNativeToken();\\n            }\\n\\n            if (routesAmount.length != routes.length) revert RoutesLengthNotMatchRoutesAmountLength();\\n\\n            /// @dev make sure inputToken always match the fromToken speicified in the route[*][0]\\n            uint256 amount;\\n            for (uint256 i = 0; i < routes.length; ++i) {\\n                totalInputTokenAmount += routesAmount[i];\\n                if (request.inputToken != routes[i][0].fromToken) {\\n                    if (inputToken.isETH() && routes[i][0].fromToken == address(WETH9)) {\\n                        amount += routesAmount[i];\\n                    } else if (inputToken == address(WETH9) && routes[i][0].fromToken.isETH()) {\\n                        amount += routesAmount[i];\\n                    } else {\\n                        revert InputTokenNotMatchRouteFromToken();\\n                    }\\n                }\\n            }\\n\\n            if (inputToken.isETH() && msg.value != totalInputTokenAmount) {\\n                revert AmountMisMatch();\\n            }\\n\\n            // in case more than one route requires wrap/unwrap, we batch it together\\n            if (amount > 0) {\\n                if (inputToken.isETH()) {\\n                    _wrap(amount);\\n                } else {\\n                    // means inputToken is WETH9 and routes[i].fromToken has .isETH()\\n                    _transferInternal(msg.sender, address(this), inputToken, totalInputTokenAmount);\\n                    _unwrap(amount);\\n                }\\n                payer = address(this);\\n            }\\n        }\\n\\n        address outputToken = request.outputToken;\\n        // check the output token balance of the recipient before the swap\\n        uint256 initialUserOutputTokenBalance = outputToken.balanceOf(msg.sender);\\n\\n        /// @dev check if we need to send the output token back to the aggregator contract, this can happen in 2 cases:\\n        ///   1. output token is ETH or WETH (wrap/unwrap might be needed)\\n        ///   2. feeConfig is not 0, which means we need to charge a fee\\n        bool sendOutputBackToAggregator = (outputToken.isETH() || outputToken == address(WETH9)) || feeConfig != 0;\\n\\n        /// @notice execute each route in sequence (assume we have several routes)\\n        for (uint256 i = 0; i < routes.length; ++i) {\\n            _execExactInRoute(\\n                payer,\\n                sendOutputBackToAggregator ? address(this) : msg.sender, // recipient\\n                routesAmount[i], // input token amount\\n                routes[i] // hops\\n            );\\n        }\\n\\n        /// @dev batch wrap/unwrap output token if necessary\\n        if (outputToken.isETH()) {\\n            _unwrapIfAny();\\n        } else if (outputToken == address(WETH9)) {\\n            _wrapIfAny();\\n        }\\n\\n        if (sendOutputBackToAggregator) {\\n            /// @dev we can assure that all the output token has been sent back to this contract\\n            outputAmtReceived = outputToken.balanceOf(address(this));\\n\\n            if (feeConfig != 0) {\\n                (uint256 feeAmount, address feeRecipient) = feeConfig.getFeeInfo(outputAmtReceived);\\n                outputAmtReceived -= feeAmount;\\n                _transferInternal(address(this), feeRecipient, outputToken, feeAmount);\\n                emit FeeRecord(feeAmount, feeRecipient);\\n            }\\n\\n            _transferInternal(address(this), msg.sender, outputToken, outputAmtReceived);\\n        } else {\\n            /// @dev output token is already with user, no need to transfer\\n        }\\n\\n        // slippage check\\n        outputAmtReceived = outputToken.balanceOf(msg.sender) - initialUserOutputTokenBalance;\\n        if (outputAmtReceived < request.minOutputAmount) revert MinReturnNotReached();\\n\\n        emit OrderRecord(inputToken, outputToken, msg.sender, totalInputTokenAmount, outputAmtReceived);\\n    }\\n\\n    /// @notice This function manages a single swap route that might involve multiple hops through different liquidity pools or swapping protocols.\\n    /// @dev It iterates through the provided `hops`, executing each segment of the route in sequence.\\n    /// @param payer The address who will pay the input token for current hop, this will be updated after each hop\\n    /// @param recipient The address who will receive the output token of the last hop in the route\\n    /// @param curInputAmount The amount of input token to be used in the current route, this will be updated after each hop\\n    /// @param hops The detailed swap information for all hops in the route\\n    function _execExactInRoute(address payer, address recipient, uint256 curInputAmount, RouterPath[] calldata hops)\\n        internal\\n    {\\n        address fromToken;\\n        bool tokenAlreadySentToNextHop;\\n        // by default we need to transfer the output token to the next hop as input\\n        // unless the current pool has already done that\\n        bool requireTransfer = true;\\n\\n        uint256 ethBalanceBeforeHop;\\n        uint256 wethBalanceBeforeHop;\\n\\n        uint256 hopLength = hops.length;\\n        for (uint256 i = 0; i < hopLength; ++i) {\\n            if (i > 0) {\\n                fromToken = hops[i].fromToken;\\n\\n                // start from the second hop, we need to check if we need to wrap/unwrap the token\\n                // since the output token of the previous hop can contain both ETH and WETH\\n                // imagine we have forks in previous hop i.e. [30% usdc->weth, 70% usdc->eth]\\n                if (fromToken.isETH()) {\\n                    uint256 wethBalanceAfterHop = WETH9.balanceOf(address(this));\\n                    // if previous hop output: WETH and current hop input: ETH, convert WETH from previous hop output to ETH\\n                    if (wethBalanceAfterHop > wethBalanceBeforeHop) {\\n                        _unwrap(wethBalanceAfterHop - wethBalanceBeforeHop);\\n                    }\\n                    uint256 ethBalanceAfterHop = address(this).balance;\\n                    curInputAmount = ethBalanceAfterHop - ethBalanceBeforeHop;\\n                } else if (fromToken == address(WETH9)) {\\n                    uint256 ethBalanceAfterHop = address(this).balance;\\n                    // if previous hop output: ETH and current hop input: WETH, convert ETH from previous hop output to WETH\\n                    if (ethBalanceAfterHop > ethBalanceBeforeHop) _wrap(ethBalanceAfterHop - ethBalanceBeforeHop);\\n                    uint256 wethBalanceAfterHop = WETH9.balanceOf(address(this));\\n                    curInputAmount = wethBalanceAfterHop - wethBalanceBeforeHop;\\n                } else {\\n                    // previous hop output is not ETH/WETH, then we don't need to worry we will touch input token\\n                    // for other routes by mistake, as the input token won't be transferred ahead of time\\n\\n                    curInputAmount = fromToken.balanceOf(address(this));\\n                }\\n                payer = address(this);\\n            }\\n\\n            address to = address(this);\\n            if (i == hopLength - 1) {\\n                to = recipient;\\n            } else if (\\n                i < hopLength - 1 && hops[i + 1].assetTo.length == 1\\n                    && !(hops[i + 1].mixAdapters[0].shouldInputWrapped() || hops[i + 1].mixAdapters[0].shouldInputUnwrapped())\\n            ) {\\n                // if next hop has only one fork and wrap/unwrap is not needed, send output to next hop directly to save one transfer\\n                to = hops[i + 1].assetTo[0];\\n                tokenAlreadySentToNextHop = true;\\n            } else {\\n                // if we have multiple forks in the next hop, we need to mannually split the output token\\n                // so we need to send the output token back to this contract first\\n                // address to = address(this);\\n                tokenAlreadySentToNextHop = false;\\n            }\\n\\n            // if not the last hop, and next hop fromToken is ETH/WETH, record the current balance of ETH/WETH before next hop\\n            if (i < hopLength - 1 && (hops[i + 1].fromToken.isETH() || hops[i + 1].fromToken == address(WETH9))) {\\n                bool willTransferFromThisContract = payer == address(this) && requireTransfer;\\n\\n                /// @dev in case input token is also output token here, we need to deduct the input token amount\\n                ethBalanceBeforeHop = address(this).balance\\n                    - (hops[i].fromToken.isETH() && willTransferFromThisContract ? curInputAmount : 0);\\n                wethBalanceBeforeHop = WETH9.balanceOf(address(this))\\n                    - (hops[i].fromToken == address(WETH9) && willTransferFromThisContract ? curInputAmount : 0);\\n            }\\n            // execute forks\\n            _execExactInHop(payer, to, curInputAmount, hops[i], requireTransfer);\\n            requireTransfer = !tokenAlreadySentToNextHop;\\n        }\\n    }\\n\\n    /// @notice Executes single hop in a route, however, input token could be further split into multiple forks.\\n    ///         It iterates through the provided `forks`, each fork represents a different liquidity pool or swapping protocol.\\n    ///         For example, a hop with 3 forks could be [30% fork1(UNIV2), 30% fork2(PCSV3), 40% fork3(PCSINFINITY)]\\n    /// @param payer The address who will pay the input token for current hop\\n    /// @param receiver The address who will receive the output token for current hop\\n    /// @param curInputAmount The amount of input token to be used in the current hop\\n    /// @param path The detailed swap information for all forks in the hop\\n    /// @param requireTransfer A boolean indicating whether the output token should be transferred to the address specified in the `assetTo` field\\n    function _execExactInHop(\\n        address payer,\\n        address receiver,\\n        uint256 curInputAmount,\\n        RouterPath calldata path,\\n        bool requireTransfer\\n    ) internal {\\n        address fromToken = path.fromToken;\\n        uint256 totalWeight;\\n        // execute multiple Adapters for a transaction pair\\n        uint256 pathLength = path.mixAdapters.length;\\n        uint256 alreadyUsedAmt = 0;\\n        for (uint256 i = 0; i < pathLength; ++i) {\\n            uint256 adapter = path.mixAdapters[i];\\n\\n            (address poolAddress, uint256 weight, bool reverse) = path.rawData[i].decodePathRawData();\\n            totalWeight += weight;\\n            if (i == pathLength - 1) {\\n                if (totalWeight != 10_000) revert PathWeightInvalid();\\n            }\\n\\n            /// @dev wrap/unwrap input token if necessary\\n            // This wrap/unwrap part is designed based on the consideration of those 4 cases:\\n            // 1. fromToken = eth, pool = weth -> X  :  wrap, transfer\\n            // 2. fromToken = weth, pool = eth -> X  :  transfer if first hop, wrap, transfer\\n            // 3. (no wrap/unwrap) fromToken = weth, pool = weth -> X :  transfer only\\n            // 4. (no wrap/unwrap) fromToken = eth, pool = eth -> X   :  transfer only\\n            uint256 _fromTokenAmount;\\n            if (i == pathLength - 1) {\\n                // fix the accumulated rounding error\\n                // Example scenario:\\n                // curInputAmount = 100\\n                // weights: [3333, 3333, 3334] (should total 10000)\\n\\n                // First fork:  (100 * 3333) / 10000 = 33.33 -> 33\\n                // Second fork: (100 * 3333) / 10000 = 33.33 -> 33\\n                // Third fork:  (100 * 3334) / 10000 = 33.34 -> 33\\n\\n                // this is to make sure that no token is left due to precision loss\\n                _fromTokenAmount = curInputAmount - alreadyUsedAmt;\\n            } else {\\n                _fromTokenAmount = weight == 10_000 ? curInputAmount : (curInputAmount * weight) / 10_000;\\n                alreadyUsedAmt += _fromTokenAmount;\\n            }\\n\\n            if (adapter.shouldInputWrapped()) {\\n                // case 1\\n                _wrap(_fromTokenAmount);\\n                fromToken = address(WETH9);\\n                payer = address(this);\\n            } else if (adapter.shouldInputUnwrapped()) {\\n                // case 2\\n                if (payer != address(this)) {\\n                    // first hop of a route, weth from external payer\\n                    _transferInternal(payer, address(this), fromToken, _fromTokenAmount);\\n                }\\n                _unwrap(_fromTokenAmount);\\n                fromToken = CommonUtils.ETH;\\n                payer = address(this);\\n            }\\n\\n            /// this means we dont need to implement adapters for those protocols, also decrease the gas cost\\n            if (adapter.isUniV2Adapter() || adapter.isPcsV2Adapter()) {\\n                if (requireTransfer) {\\n                    _transferInternal(payer, path.assetTo[i], fromToken, _fromTokenAmount);\\n                }\\n\\n                // for uni/pcs v2, we have different fee ratio\\n                uint256 feeRatio = adapter.isUniV2Adapter() ? UNIV2_EXCLUDING_FEE_RATIO : PCSV2_EXCLUDING_FEE_RATIO;\\n                if (reverse) {\\n                    uniV2StyledSwapExactOneForZero(receiver, poolAddress, feeRatio);\\n                } else {\\n                    uniV2StyledSwapExactZeroForOne(receiver, poolAddress, feeRatio);\\n                }\\n            } else if (adapter.isUniV3StyledAdapter()) {\\n                /// @dev path.extraData[i] equal to abi.encode(uint160 sqrtX96PriceLimit, address fromToken, address toToken, uint24 fee)\\n                uniV3StyledExactInSwap(_fromTokenAmount, payer, receiver, poolAddress, path.extraData[i]);\\n            } else {\\n                address adapterAddress = adapter.bytes32ToAddress();\\n                if (!isAdapterWhitelisted[adapterAddress]) revert AdapterNotWhitelisted();\\n\\n                // execute the swap through the external adapter\\n                if (requireTransfer) {\\n                    _transferInternal(payer, path.assetTo[i], fromToken, _fromTokenAmount);\\n                }\\n\\n                if (reverse) {\\n                    IAdapter(adapterAddress).swapExactOneForZero(receiver, poolAddress, path.extraData[i]);\\n                } else {\\n                    IAdapter(adapterAddress).swapExactZeroForOne(receiver, poolAddress, path.extraData[i]);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IAggregator\\n    function whitelistAdapter(address adapter, bool whitelisted) external onlyOwner {\\n        isAdapterWhitelisted[adapter] = whitelisted;\\n\\n        emit AdapterWhitelisted(adapter, whitelisted);\\n    }\\n\\n    /// @notice the aggregation contract is not expected to hold tokens\\n    ///         this function helps to rescue tokens left in the contract for any reasons\\n    function sweep(address token, address recipient, uint256 amountMinimum) external isNotLocked {\\n        uint256 balance = token.balanceOf(address(this));\\n        if (balance < amountMinimum) revert InsufficientToken();\\n        if (balance > 0) _transferInternal(address(this), recipient, token, balance);\\n    }\\n}\\n\"},\"src/adapters/UniV3StyledAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IUniV3StyledPool} from \\\"../interfaces/IUniV3StyledPool.sol\\\";\\nimport {IUniV3StyledSwapCallback} from \\\"../interfaces/IUniV3StyledSwapCallback.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {UniV3TickMath} from \\\"../libraries/UniV3TickMath.sol\\\";\\nimport {Payment} from \\\"../base/Payment.sol\\\";\\nimport {SafeCast} from \\\"openzeppelin-contracts/contracts/utils/math/SafeCast.sol\\\";\\nimport {ImmutableState} from \\\"../base/ImmutableState.sol\\\";\\n\\n/// @title UniV3StyledAdapter\\n/// @notice This contract can used to swap tokens on any Uniswap V3 compatible pools which include: PancakeSwap, UniSwap. Any other protocol to be added require code changes to this file\\n/// @dev It's designed to be inlined into Aggregator contract to reduce gas costs, and it's not meant to be deployed on its own.\\n///      Also it will not comply with IAdapter interface to avoid naming conflicts.\\nabstract contract UniV3StyledAdapter is IUniV3StyledSwapCallback, Payment, ImmutableState {\\n    using SafeCast for uint256;\\n\\n    /// @notice throw when both amount0Delta and amount1Delta are non-positive\\n    error BothDeltaNonPositive();\\n\\n    /// @notice throw when the caller is not a valid UniSwap/PancakeSwap V3 pool\\n    error V3InvalidCaller();\\n\\n    function uniV3StyledExactInSwap(uint256 amountIn, address from, address to, address pool, bytes calldata data)\\n        internal\\n    {\\n        (uint160 sqrtX96PriceLimit, address fromToken, address toToken, uint24 fee) =\\n            abi.decode(data, (uint160, address, address, uint24));\\n\\n        bool zeroForOne = fromToken < toToken;\\n\\n        IUniV3StyledPool(pool).swap(\\n            to,\\n            zeroForOne,\\n            /// @dev amt > 0 means exact input in v3, hence amountIn must be positive and can't overflow\\n            amountIn.toInt256(),\\n            sqrtX96PriceLimit == 0\\n                ? (zeroForOne ? UniV3TickMath.MIN_SQRT_RATIO + 1 : UniV3TickMath.MAX_SQRT_RATIO - 1)\\n                : sqrtX96PriceLimit,\\n            abi.encode(fromToken, toToken, fee, from, amountIn, msg.sender)\\n        );\\n    }\\n\\n    /// @notice for PancakeSwap V3\\n    function pancakeV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\\n        (address tokenIn, address tokenOut, uint24 fee, address payer, uint256 amountIn, address refundTo) =\\n            abi.decode(_data, (address, address, uint24, address, uint256, address));\\n        if (\\n            _computePoolAddress(PANCAKESWAP_V3_DEPLOYER, PANCAKESWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)\\n                != msg.sender\\n        ) revert V3InvalidCaller();\\n        _callback(amount0Delta, amount1Delta, tokenIn, tokenOut, payer, amountIn, refundTo);\\n    }\\n\\n    /// @notice for Uniswap V3\\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\\n        (address tokenIn, address tokenOut, uint24 fee, address payer, uint256 amountIn, address refundTo) =\\n            abi.decode(_data, (address, address, uint24, address, uint256, address));\\n        if (\\n            _computePoolAddress(UNISWAP_V3_FACTORY, UNISWAP_V3_POOL_INIT_CODE_HASH, tokenIn, tokenOut, fee)\\n                != msg.sender\\n        ) {\\n            revert V3InvalidCaller();\\n        }\\n        _callback(amount0Delta, amount1Delta, tokenIn, tokenOut, payer, amountIn, refundTo);\\n    }\\n\\n    function _callback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        address tokenIn,\\n        address tokenOut,\\n        address payer,\\n        uint256 amountIn,\\n        address refundTo\\n    ) internal {\\n        if (amount0Delta <= 0 && amount1Delta <= 0) {\\n            // swaps entirely within 0-liquidity regions are not supported\\n            revert BothDeltaNonPositive();\\n        }\\n\\n        (bool isExactInput, uint256 amountToPay) =\\n            amount0Delta > 0 ? (tokenIn < tokenOut, uint256(amount0Delta)) : (tokenOut < tokenIn, uint256(amount1Delta));\\n\\n        if (!isExactInput) {\\n            tokenIn = tokenOut; // swap in/out because exact output swaps are reversed\\n        }\\n\\n        _transferInternal(payer, msg.sender, tokenIn, amountToPay);\\n\\n        /// @dev refund the remaining amount to the user if partial swap. eg. when sqrtPriceLimit is reached or tick hits boundary\\n        /// @dev payer == address(this) means tokens are already in the contract otherwise no need to refund\\n        if (amountIn > amountToPay && payer == address(this)) {\\n            _transferInternal(address(this), refundTo, tokenIn, amountIn - amountToPay);\\n        }\\n    }\\n\\n    function _computePoolAddress(\\n        address deployerOrFactory,\\n        bytes32 initCodeHash,\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) internal pure returns (address pool) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n        pool = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex\\\"ff\\\", deployerOrFactory, keccak256(abi.encode(tokenA, tokenB, fee)), initCodeHash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/types/BalanceDelta.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from \\\"../libraries/SafeCast.sol\\\";\\n\\n/// @dev Two `int128` values packed into a single `int256` where the upper 128 bits represent the amount0\\n/// and the lower 128 bits represent the amount1.\\ntype BalanceDelta is int256;\\n\\nusing {add as +, sub as -, eq as ==, neq as !=} for BalanceDelta global;\\nusing BalanceDeltaLibrary for BalanceDelta global;\\nusing SafeCast for int256;\\n\\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\\n    assembly (\\\"memory-safe\\\") {\\n        balanceDelta := or(shl(128, _amount0), and(sub(shl(128, 1), 1), _amount1))\\n    }\\n}\\n\\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    int256 res0;\\n    int256 res1;\\n    assembly (\\\"memory-safe\\\") {\\n        let a0 := sar(128, a)\\n        let a1 := signextend(15, a)\\n        let b0 := sar(128, b)\\n        let b1 := signextend(15, b)\\n        res0 := add(a0, b0)\\n        res1 := add(a1, b1)\\n    }\\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\\n}\\n\\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\\n    int256 res0;\\n    int256 res1;\\n    assembly (\\\"memory-safe\\\") {\\n        let a0 := sar(128, a)\\n        let a1 := signextend(15, a)\\n        let b0 := sar(128, b)\\n        let b1 := signextend(15, b)\\n        res0 := sub(a0, b0)\\n        res1 := sub(a1, b1)\\n    }\\n    return toBalanceDelta(res0.toInt128(), res1.toInt128());\\n}\\n\\nfunction eq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\\n    return BalanceDelta.unwrap(a) == BalanceDelta.unwrap(b);\\n}\\n\\nfunction neq(BalanceDelta a, BalanceDelta b) pure returns (bool) {\\n    return BalanceDelta.unwrap(a) != BalanceDelta.unwrap(b);\\n}\\n\\n/// @notice Library for getting the amount0 and amount1 deltas from the BalanceDelta type\\nlibrary BalanceDeltaLibrary {\\n    /// @notice Constant for a BalanceDelta of zero value\\n    BalanceDelta public constant ZERO_DELTA = BalanceDelta.wrap(0);\\n\\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\\n        assembly (\\\"memory-safe\\\") {\\n            _amount0 := sar(128, balanceDelta)\\n        }\\n    }\\n\\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\\n        assembly (\\\"memory-safe\\\") {\\n            _amount1 := signextend(15, balanceDelta)\\n        }\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/interfaces/IVault.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {IVaultToken} from \\\"./IVaultToken.sol\\\";\\n\\ninterface IVault is IVaultToken {\\n    event AppRegistered(address indexed app);\\n\\n    /// @notice Thrown when a app is not registered\\n    error AppUnregistered();\\n\\n    /// @notice Thrown when a currency is not netted out after a lock\\n    error CurrencyNotSettled();\\n\\n    /// @notice Thrown when there is already a locker\\n    /// @param locker The address of the current locker\\n    error LockerAlreadySet(address locker);\\n\\n    /// @notice Thrown when passing in msg.value for non-native currency\\n    error SettleNonNativeCurrencyWithValue();\\n\\n    /// @notice Thrown when `clear` is called with an amount that is not exactly equal to the open currency delta.\\n    error MustClearExactPositiveDelta();\\n\\n    /// @notice Thrown when there is no locker\\n    error NoLocker();\\n\\n    /// @notice Thrown when collectFee is attempted on a token that is synced.\\n    error FeeCurrencySynced();\\n\\n    function isAppRegistered(address app) external returns (bool);\\n\\n    /// @notice Returns the reserves for a a given pool type and currency\\n    function reservesOfApp(address app, Currency currency) external view returns (uint256);\\n\\n    /// @notice register an app so that it can perform accounting base on vault\\n    function registerApp(address app) external;\\n\\n    /// @notice Returns the locker who is locking the vault\\n    function getLocker() external view returns (address locker);\\n\\n    /// @notice Returns the reserve and its amount that is currently being stored in trnasient storage\\n    function getVaultReserve() external view returns (Currency, uint256);\\n\\n    /// @notice Returns lock data\\n    function getUnsettledDeltasCount() external view returns (uint256 count);\\n\\n    /// @notice Get the current delta for a locker in the given currency\\n    /// @param currency The currency for which to lookup the delta\\n    function currencyDelta(address settler, Currency currency) external view returns (int256);\\n\\n    /// @notice All operations go through this function\\n    /// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockCallback(data)`\\n    /// @return The data returned by the call to `ILockCallback(msg.sender).lockCallback(data)`\\n    function lock(bytes calldata data) external returns (bytes memory);\\n\\n    /// @notice Called by registered app to account for a change in the pool balance,\\n    /// convenient for AMM pool manager, typically after modifyLiquidity, swap, donate,\\n    /// include the case where hookDelta is involved\\n    /// @param currency0 The PoolKey currency0 to update\\n    /// @param currency1 The PoolKey currency1 to update\\n    /// @param delta The change in the pool's balance\\n    /// @param settler The address whose delta will be updated\\n    /// @param hookDelta The change in the pool's balance from hook\\n    /// @param hook The address whose hookDelta will be updated\\n    function accountAppBalanceDelta(\\n        Currency currency0,\\n        Currency currency1,\\n        BalanceDelta delta,\\n        address settler,\\n        BalanceDelta hookDelta,\\n        address hook\\n    ) external;\\n\\n    /// @notice Called by registered app to account for a change in the pool balance,\\n    /// convenient for AMM pool manager, typically after modifyLiquidity, swap, donate\\n    /// @param currency0 The PoolKey currency0 to update\\n    /// @param currency1 The PoolKey currency1 to update\\n    /// @param delta The change in the pool's balance\\n    /// @param settler The address whose delta will be updated\\n    function accountAppBalanceDelta(Currency currency0, Currency currency1, BalanceDelta delta, address settler)\\n        external;\\n\\n    /// @notice This works as a general accounting mechanism for non-dex app\\n    /// @param currency The currency to update\\n    /// @param delta The change in the balance\\n    /// @param settler The address whose delta will be updated\\n    function accountAppBalanceDelta(Currency currency, int128 delta, address settler) external;\\n\\n    /// @notice Called by the user to net out some value owed to the user\\n    /// @dev Will revert if the requested amount is not available, consider using `mint` instead\\n    /// @dev Can also be used as a mechanism for free flash loans\\n    function take(Currency currency, address to, uint256 amount) external;\\n\\n    /// @notice Writes the current ERC20 balance of the specified currency to transient storage\\n    /// This is used to checkpoint balances for the manager and derive deltas for the caller.\\n    /// @dev This MUST be called before any ERC20 tokens are sent into the contract, but can be skipped\\n    /// for native tokens because the amount to settle is determined by the sent value.\\n    /// However, if an ERC20 token has been synced and not settled, and the caller instead wants to settle\\n    /// native funds, this function can be called with the native currency to then be able to settle the native currency\\n    function sync(Currency token0) external;\\n\\n    /// @notice Called by the user to pay what is owed\\n    function settle() external payable returns (uint256 paid);\\n\\n    /// @notice Called by the user to pay on behalf of another address\\n    /// @param recipient The address to credit for the payment\\n    /// @return paid The amount of currency settled\\n    function settleFor(address recipient) external payable returns (uint256 paid);\\n\\n    /// @notice WARNING - Any currency that is cleared, will be non-retreivable, and locked in the contract permanently.\\n    /// A call to clear will zero out a positive balance WITHOUT a corresponding transfer.\\n    /// @dev This could be used to clear a balance that is considered dust.\\n    /// Additionally, the amount must be the exact positive balance. This is to enforce that the caller is aware of the amount being cleared.\\n    function clear(Currency currency, uint256 amount) external;\\n\\n    /// @notice Called by app to collect any fee related\\n    /// @dev no restriction on caller, underflow happen if caller collect more than the reserve\\n    function collectFee(Currency currency, uint256 amount, address recipient) external;\\n\\n    /// @notice Called by the user to store surplus tokens in the vault\\n    function mint(address to, Currency currency, uint256 amount) external;\\n\\n    /// @notice Called by the user to use surplus tokens for payment settlement\\n    function burn(address from, Currency currency, uint256 amount) external;\\n}\\n\"},\"lib/infinity-periphery/src/base/ReentrancyLock.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.24;\\n\\n/// @notice A transient reentrancy lock, that stores the caller's address as the lock\\ncontract ReentrancyLock {\\n    // The slot holding the locker state, transiently. bytes32(uint256(keccak256(\\\"LockedBy\\\")) - 1)\\n    bytes32 constant LOCKED_BY_SLOT = 0x0aedd6bde10e3aa2adec092b02a3e3e805795516cda41f27aa145b8f300af87a;\\n\\n    error ContractLocked();\\n\\n    modifier isNotLocked() {\\n        if (_getLocker() != address(0)) revert ContractLocked();\\n        _setLocker(msg.sender);\\n        _;\\n        _setLocker(address(0));\\n    }\\n\\n    function _setLocker(address locker) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            tstore(LOCKED_BY_SLOT, locker)\\n        }\\n    }\\n\\n    function _getLocker() internal view returns (address locker) {\\n        assembly (\\\"memory-safe\\\") {\\n            locker := tload(LOCKED_BY_SLOT)\\n        }\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/pool-cl/libraries/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = a * b\\n            // Compute the product mod 2**256 and mod 2**256 - 1\\n            // then use the Chinese Remainder Theorem to reconstruct\\n            // the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2**256 + prod0\\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly (\\\"memory-safe\\\") {\\n                let mm := mulmod(a, b, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                assembly (\\\"memory-safe\\\") {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly (\\\"memory-safe\\\") {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (0 - denominator) & denominator;\\n            // Divide denominator by power of two\\n            assembly (\\\"memory-safe\\\") {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly (\\\"memory-safe\\\") {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly (\\\"memory-safe\\\") {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the preconditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = mulDiv(a, b, denominator);\\n            if (mulmod(a, b, denominator) != 0) {\\n                require(++result > 0);\\n            }\\n        }\\n    }\\n}\\n\"},\"src/libraries/CommonUtils.sol\":{\"content\":\"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\n\\nlibrary CommonUtils {\\n    address public constant ETH = address(0x0);\\n\\n    function isETH(address token) internal pure returns (bool) {\\n        return token == ETH;\\n    }\\n\\n    function balanceOf(address token, address owner) internal view returns (uint256) {\\n        if (isETH(token)) {\\n            return owner.balance;\\n        } else {\\n            return ERC20(token).balanceOf(owner);\\n        }\\n    }\\n\\n    uint256 private constant ADDRESS_MASK = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\\n    /// @notice Converts a uint256 value into an address.\\n    /// @param param The uint256 value to be converted.\\n    /// @return result The address obtained from the conversion.\\n    /// @dev This function is used to extract an address from a uint256,\\n    /// typically used when dealing with low-level data operations or when addresses are packed into larger data types.\\n\\n    function bytes32ToAddress(uint256 param) internal pure returns (address result) {\\n        assembly {\\n            result := and(param, ADDRESS_MASK)\\n        }\\n    }\\n}\\n\"},\"src/adapters/UniV2StyledAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IUniV2StyledPool} from \\\"../interfaces/IUniV2StyledPool.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title UniV2StyledAdapter\\n/// @notice This contract can used to swap tokens on any Uniswap V2 compatible pools including PancakeSwap, UniSwap, etc.\\n/// @dev It's designed to be inlined into Aggregator contract to reduce gas costs, and it's not meant to be deployed on its own.\\n///      Also it will be complying with IAdapter interface to avoid naming conflicts.\\nabstract contract UniV2StyledAdapter {\\n    /// @dev this is the percentage of principal amount that will be used for swap after charging fee\\n    ///      10000 means no swap fee i.e. 100% of principal amount will be used for swap\\n    ///      for example, the value should be 9970 for uni i.e. 0.3% fee and 9975 for pancake i.e. 0.25% fee\\n    uint256 internal constant UNIV2_EXCLUDING_FEE_RATIO = 9970;\\n    uint256 internal constant PCSV2_EXCLUDING_FEE_RATIO = 9975;\\n\\n    error UNIV2_STYLED_ADAPTER_INSUFFICIENT_LIQUIDITY();\\n\\n    function uniV2StyledSwapExactZeroForOne(address to, address pool, uint256 excludingFeeRatio) internal {\\n        address baseToken = IUniV2StyledPool(pool).token0();\\n        (uint256 reserveIn, uint256 reserveOut,) = IUniV2StyledPool(pool).getReserves();\\n        if (reserveIn == 0 || reserveOut == 0) revert UNIV2_STYLED_ADAPTER_INSUFFICIENT_LIQUIDITY();\\n\\n        uint256 balance0 = IERC20(baseToken).balanceOf(pool);\\n        uint256 sellBaseAmount = balance0 - reserveIn;\\n\\n        uint256 sellBaseAmountWithFee = sellBaseAmount * excludingFeeRatio;\\n        uint256 numerator = sellBaseAmountWithFee * reserveOut;\\n        uint256 denominator = reserveIn * 10000 + sellBaseAmountWithFee;\\n        uint256 receiveQuoteAmount = numerator / denominator;\\n        IUniV2StyledPool(pool).swap(0, receiveQuoteAmount, to, new bytes(0));\\n    }\\n\\n    function uniV2StyledSwapExactOneForZero(address to, address pool, uint256 excludingFeeRatio) internal {\\n        address quoteToken = IUniV2StyledPool(pool).token1();\\n        (uint256 reserveOut, uint256 reserveIn,) = IUniV2StyledPool(pool).getReserves();\\n        if (reserveIn == 0 || reserveOut == 0) revert UNIV2_STYLED_ADAPTER_INSUFFICIENT_LIQUIDITY();\\n\\n        uint256 balance1 = IERC20(quoteToken).balanceOf(pool);\\n        uint256 sellQuoteAmount = balance1 - reserveIn;\\n\\n        uint256 sellQuoteAmountWithFee = sellQuoteAmount * excludingFeeRatio;\\n        uint256 numerator = sellQuoteAmountWithFee * reserveOut;\\n        uint256 denominator = reserveIn * 10000 + sellQuoteAmountWithFee;\\n        uint256 receiveBaseAmount = numerator / denominator;\\n        IUniV2StyledPool(pool).swap(receiveBaseAmount, 0, to, new bytes(0));\\n    }\\n}\\n\"},\"src/base/ImmutableState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.0;\\n\\n/// @title Immutable State\\n/// @notice A collection of immutable state variables, commonly used across multiple contracts\\ncontract ImmutableState {\\n    /// @notice Throw when the pass in address is zero\\n    error ZeroAddress();\\n\\n    /// @notice Throw when the init code hash is invalid\\n    error InvalidInitCodeHash();\\n\\n    /// @dev The address of UniSwapV3 Factory\\n    address internal immutable UNISWAP_V3_FACTORY;\\n\\n    /// @dev The UniSwapV3Pool initcodehash\\n    bytes32 internal immutable UNISWAP_V3_POOL_INIT_CODE_HASH;\\n\\n    /// @dev The address of PancakeSwap V3 Deployer\\n    address internal immutable PANCAKESWAP_V3_DEPLOYER;\\n\\n    /// @dev The PancakeSwapV3Pool initcodehash\\n    bytes32 internal immutable PANCAKESWAP_V3_POOL_INIT_CODE_HASH;\\n\\n    constructor(\\n        address _uniV3Factory,\\n        bytes32 _uniV3PoolInitCodeHash,\\n        address _pcsV3Deployer,\\n        bytes32 _pcsV3PoolInitCodeHash\\n    ) {\\n        if (_uniV3Factory == address(0) || _pcsV3Deployer == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        if (_uniV3PoolInitCodeHash == bytes32(0) || _pcsV3PoolInitCodeHash == bytes32(0)) {\\n            revert InvalidInitCodeHash();\\n        }\\n\\n        UNISWAP_V3_FACTORY = _uniV3Factory;\\n        UNISWAP_V3_POOL_INIT_CODE_HASH = _uniV3PoolInitCodeHash;\\n        PANCAKESWAP_V3_DEPLOYER = _pcsV3Deployer;\\n        PANCAKESWAP_V3_POOL_INIT_CODE_HASH = _pcsV3PoolInitCodeHash;\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/utils/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"},\"src/base/NativeWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Copyright (C) 2024 PancakeSwap\\npragma solidity ^0.8.0;\\n\\nimport {IWETH9} from \\\"infinity-periphery/src/interfaces/external/IWETH9.sol\\\";\\nimport {ImmutableState} from \\\"./ImmutableState.sol\\\";\\n\\n/// @title Native Wrapper\\n/// @notice Used for wrapping and unwrapping native\\nabstract contract NativeWrapper {\\n    /// @notice The address for WETH9\\n    IWETH9 public immutable WETH9;\\n\\n    /// @notice Thrown when the contract does not have enough ETH to wrap\\n    error InsufficientETH();\\n\\n    /// @notice Thrown when the contract does not have enough WETH to unwrap\\n    error InsufficientWETH();\\n\\n    constructor(IWETH9 _weth9) {\\n        WETH9 = _weth9;\\n    }\\n\\n    /// @dev The amount should already be <= the current balance in this contract.\\n    function _wrap(uint256 amount) internal {\\n        if (amount > address(this).balance) {\\n            revert InsufficientETH();\\n        }\\n\\n        if (amount > 0) WETH9.deposit{value: amount}();\\n    }\\n\\n    function _wrapIfAny() internal {\\n        uint256 amount = address(this).balance;\\n\\n        if (amount > 0) WETH9.deposit{value: amount}();\\n    }\\n\\n    /// @dev The amount should already be <= the current balance in this contract.\\n    function _unwrap(uint256 amount) internal {\\n        uint256 wethBalance = WETH9.balanceOf(address(this));\\n\\n        if (wethBalance < amount) {\\n            revert InsufficientWETH();\\n        }\\n\\n        if (amount > 0) WETH9.withdraw(amount);\\n    }\\n\\n    function _unwrapIfAny() internal {\\n        uint256 wethBalance = WETH9.balanceOf(address(this));\\n\\n        if (wethBalance > 0) WETH9.withdraw(wethBalance);\\n    }\\n\\n    /// @notice we might receive ETH from any external adapter in the future\\n    receive() external payable {}\\n}\\n\"},\"src/base/Payment.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeTransferLib, ERC20} from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ImmutableState} from \\\"./ImmutableState.sol\\\";\\nimport {CommonUtils} from \\\"../libraries/CommonUtils.sol\\\";\\n\\nabstract contract Payment {\\n    using SafeTransferLib for *;\\n    using CommonUtils for address;\\n\\n    /// @notice Transfers tokens internally within the contract\\n    /// @param payer The address of the payer.\\n    /// @param to The address of the receiver.\\n    /// @param token The address of the token to be transferred.\\n    /// @param amount The amount of tokens to be transferred.\\n    /// @dev Handles the transfer of ERC20 tokens or native tokens within the contract.\\n    function _transferInternal(address payer, address to, address token, uint256 amount) internal {\\n        if (amount == 0) return;\\n        if (payer == to) return;\\n\\n        if (token.isETH()) {\\n            to.safeTransferETH(amount);\\n        } else {\\n            if (payer == address(this)) {\\n                ERC20(token).safeTransfer(to, amount);\\n            } else {\\n                ERC20(token).safeTransferFrom(payer, to, amount);\\n            }\\n        }\\n    }\\n}\\n\"},\"src/interfaces/IUniV2StyledPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniV2StyledPool {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\\n\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\"},\"src/libraries/PathRawDataHelper.sol\":{\"content\":\"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title PathRawDataDecoder\\n/// @notice each raw data is a 256-bit unsigned integer, which is used to store the following information:\\n///         - pool address: the address of the pool where the swap will be executed\\n///         - reverse: the swap direction, swap token0 for token1 if this field is 0, otherwise reverse the direction\\n///         - weight: how much swap amount of input token will be distributed to this fork among a hop, 10000 means 100%\\n///  here is the layout of the raw data:\\n///  |  0 - 159 bits  |   160 - 175 bits  |  255    |\\n///  |  pool address  |   weight          | reverse |\\nlibrary PathRawDataHelper {\\n    uint256 private constant RAWDATA_ADDRESS_MASK = 0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff;\\n    uint256 private constant RAWDATA_REVERSE_MASK = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant RAWDATA_WEIGHT_MASK = 0x00000000000000000000ffff0000000000000000000000000000000000000000;\\n\\n    function decodePathRawData(uint256 rawData)\\n        internal\\n        pure\\n        returns (address poolAddr, uint256 weight, bool reverse)\\n    {\\n        assembly {\\n            /// @notice poolAddress is the address of the pool where the swap will be executed\\n            poolAddr := and(rawData, RAWDATA_ADDRESS_MASK)\\n            /// @notice by default swap token0 for token1, this field is used to reverse the direction\\n            reverse := and(rawData, RAWDATA_REVERSE_MASK)\\n            /// @notice weight speficies how much swap volume will be distributed to this pool, 10000 means 100%\\n            weight := shr(160, and(rawData, RAWDATA_WEIGHT_MASK))\\n        }\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/libraries/CustomRevert.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Library for reverting with custom errors efficiently\\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\\nlibrary CustomRevert {\\n    /// @dev ERC-7751 error for wrapping bubbled up reverts\\n    error WrappedError(address target, bytes4 selector, bytes reason, bytes details);\\n\\n    /// @notice bubble up the revert message returned by a call and revert with a wrapped ERC-7751 error\\n    /// @dev this method can be vulnerable to revert data bombs\\n    function bubbleUpAndRevertWith(\\n        address revertingContract,\\n        bytes4 revertingFunctionSelector,\\n        bytes4 additionalContext\\n    ) internal pure {\\n        bytes4 wrappedErrorSelector = WrappedError.selector;\\n        assembly (\\\"memory-safe\\\") {\\n            // Ensure the size of the revert data is a multiple of 32 bytes\\n            let encodedDataSize := mul(div(add(returndatasize(), 31), 32), 32)\\n\\n            let fmp := mload(0x40)\\n\\n            // Encode wrapped error selector, address, function selector, offset, additional context, size, revert reason\\n            mstore(fmp, wrappedErrorSelector)\\n            mstore(add(fmp, 0x04), and(revertingContract, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(\\n                add(fmp, 0x24),\\n                and(revertingFunctionSelector, 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n            )\\n            // offset revert reason\\n            mstore(add(fmp, 0x44), 0x80)\\n            // offset additional context\\n            mstore(add(fmp, 0x64), add(0xa0, encodedDataSize))\\n            // size revert reason\\n            mstore(add(fmp, 0x84), returndatasize())\\n            // revert reason\\n            returndatacopy(add(fmp, 0xa4), 0, returndatasize())\\n            // size additional context\\n            mstore(add(fmp, add(0xa4, encodedDataSize)), 0x04)\\n            // additional context\\n            mstore(\\n                add(fmp, add(0xc4, encodedDataSize)),\\n                and(additionalContext, 0xffffffff00000000000000000000000000000000000000000000000000000000)\\n            )\\n            revert(fmp, add(0xe4, encodedDataSize))\\n        }\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/interfaces/IVaultToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {PoolId} from \\\"../types/PoolId.sol\\\";\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {BalanceDelta} from \\\"../types/BalanceDelta.sol\\\";\\nimport {IPoolManager} from \\\"./IPoolManager.sol\\\";\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\n\\ninterface IVaultToken {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OperatorSet(address indexed owner, address indexed operator, bool approved);\\n\\n    event Approval(address indexed owner, address indexed spender, Currency indexed currency, uint256 amount);\\n\\n    event Transfer(address caller, address indexed from, address indexed to, Currency indexed currency, uint256 amount);\\n\\n    /// @notice get the amount of owner's surplus token in vault\\n    /// @param owner The address you want to query the balance of\\n    /// @param currency The currency you want to query the balance of\\n    /// @return balance The balance of the specified address\\n    function balanceOf(address owner, Currency currency) external view returns (uint256 balance);\\n\\n    /// @notice get the amount that owner has authorized for spender to use\\n    /// @param owner The address of the owner\\n    /// @param spender The address who is allowed to spend the owner's token\\n    /// @param currency The currency the spender is allowed to spend\\n    /// @return amount The amount of token the spender is allowed to spend\\n    function allowance(address owner, address spender, Currency currency) external view returns (uint256 amount);\\n\\n    /// @notice approve spender for using user's token\\n    /// @param spender The address msg.sender is approving to spend the his token\\n    /// @param currency The currency the spender is allowed to spend\\n    /// @param amount The amount of token the spender is allowed to spend\\n    /// @return bool Whether the approval was successful or not\\n    function approve(address spender, Currency currency, uint256 amount) external returns (bool);\\n\\n    /// @notice transfer msg.sender's token to someone else\\n    /// @param to The address to transfer the token to\\n    /// @param currency The currency to transfer\\n    /// @param amount The amount of token to transfer\\n    /// @return bool Whether the transfer was successful or not\\n    function transfer(address to, Currency currency, uint256 amount) external returns (bool);\\n\\n    /// @notice transfer from address's token on behalf of him\\n    /// @param from The address to transfer the token from\\n    /// @param to The address to transfer the token to\\n    /// @param currency The currency to transfer\\n    /// @param amount The amount of token to transfer\\n    /// @return bool Whether the transfer was successful or not\\n    function transferFrom(address from, address to, Currency currency, uint256 amount) external returns (bool);\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"},\"src/interfaces/IUniV3StyledPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniV3StyledPool {\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n}\\n\"},\"src/libraries/UniV3TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary UniV3TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    uint160 public constant SQRT_RATIO_1_1 = 79228162514264337593543950336;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(uint24(MAX_TICK)), \\\"T\\\");\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) {\\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        }\\n        if (absTick & 0x4 != 0) {\\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        }\\n        if (absTick & 0x8 != 0) {\\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        }\\n        if (absTick & 0x10 != 0) {\\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        }\\n        if (absTick & 0x20 != 0) {\\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        }\\n        if (absTick & 0x40 != 0) {\\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        }\\n        if (absTick & 0x80 != 0) {\\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        }\\n        if (absTick & 0x100 != 0) {\\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        }\\n        if (absTick & 0x200 != 0) {\\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        }\\n        if (absTick & 0x400 != 0) {\\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        }\\n        if (absTick & 0x800 != 0) {\\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        }\\n        if (absTick & 0x1000 != 0) {\\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        }\\n        if (absTick & 0x2000 != 0) {\\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        }\\n        if (absTick & 0x4000 != 0) {\\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        }\\n        if (absTick & 0x8000 != 0) {\\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        }\\n        if (absTick & 0x10000 != 0) {\\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        }\\n        if (absTick & 0x20000 != 0) {\\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        }\\n        if (absTick & 0x40000 != 0) {\\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        }\\n        if (absTick & 0x80000 != 0) {\\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n        }\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, \\\"R\\\");\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/src/interfaces/IPoolManager.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IHooks} from \\\"./IHooks.sol\\\";\\nimport {PoolKey} from \\\"../types/PoolKey.sol\\\";\\nimport {PoolId} from \\\"../types/PoolId.sol\\\";\\nimport {Currency} from \\\"../types/Currency.sol\\\";\\n\\ninterface IPoolManager {\\n    /// @notice Thrown when trying to interact with a non-initialized pool\\n    error PoolNotInitialized();\\n\\n    /// @notice PoolKey must have currencies where address(currency0) < address(currency1)\\n    error CurrenciesInitializedOutOfOrder(address currency0, address currency1);\\n\\n    /// @notice Thrown when a call to updateDynamicLPFee is made by an address that is not the hook,\\n    /// or on a pool is not a dynamic fee pool.\\n    error UnauthorizedDynamicLPFeeUpdate();\\n\\n    /// @notice Emitted when lp fee is updated\\n    /// @dev The event is emitted even if the updated fee value is the same as previous one\\n    event DynamicLPFeeUpdated(PoolId indexed id, uint24 dynamicLPFee);\\n\\n    /// @notice Updates lp fee for a dyanmic fee pool\\n    /// @dev Some of the use case could be:\\n    ///   1) when hook#beforeSwap() is called and hook call this function to update the lp fee\\n    ///   2) For BinPool only, when hook#beforeMint() is called and hook call this function to update the lp fee\\n    ///   3) other use case where the hook might want to on an ad-hoc basis increase/reduce lp fee\\n    function updateDynamicLPFee(PoolKey memory key, uint24 newDynamicLPFee) external;\\n\\n    /// @notice Return PoolKey for a given PoolId\\n    function poolIdToPoolKey(PoolId id)\\n        external\\n        view\\n        returns (\\n            Currency currency0,\\n            Currency currency1,\\n            IHooks hooks,\\n            IPoolManager poolManager,\\n            uint24 fee,\\n            bytes32 parameters\\n        );\\n}\\n\"},\"src/interfaces/IAdapter.sol\":{\"content\":\"/// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAdapter {\\n    function swapExactZeroForOne(address to, address pool, bytes memory data) external;\\n\\n    function swapExactOneForZero(address to, address pool, bytes memory data) external;\\n}\\n\"},\"lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\"}},\"settings\":{\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"outputSelection\":{\"*\":{\"*\":[\"evm.bytecode\",\"evm.deployedBytecode\",\"devdoc\",\"userdoc\",\"metadata\",\"abi\"]}},\"remappings\":[\"infinity-core/=lib/infinity-periphery/lib/infinity-core/\",\"ds-test/=lib/infinity-periphery/lib/infinity-core/lib/forge-std/lib/ds-test/src/\",\"openzeppelin-contracts/=lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/\",\"solmate/=lib/infinity-periphery/lib/infinity-core/lib/solmate/\",\"@openzeppelin/=lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/\",\"@openzeppelin/contracts/=lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/contracts/\",\"erc4626-tests/=lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/lib/erc4626-tests/\",\"forge-gas-snapshot/=lib/infinity-periphery/lib/infinity-core/lib/forge-gas-snapshot/src/\",\"forge-std/=lib/forge-std/src/\",\"halmos-cheatcodes/=lib/infinity-periphery/lib/infinity-core/lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/\",\"infinity-periphery/=lib/infinity-periphery/\",\"pancake-create3-factory/=lib/infinity-periphery/lib/pancake-create3-factory/\",\"permit2/=lib/infinity-periphery/lib/permit2/\"],\"viaIR\":true}},\"ABI\":\"[{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"_uniV3Factory\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"bytes32\\\",\\\"name\\\":\\\"_uniV3PoolInitCodeHash\\\",\\\"type\\\":\\\"bytes32\\\"},{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"_pcsV3Deployer\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"bytes32\\\",\\\"name\\\":\\\"_pcsV3PoolInitCodeHash\\\",\\\"type\\\":\\\"bytes32\\\"},{\\\"internalType\\\":\\\"contract IWETH9\\\",\\\"name\\\":\\\"_weth9\\\",\\\"type\\\":\\\"address\\\"}],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"constructor\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"AdapterNotWhitelisted\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"AmountMisMatch\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"BothDeltaNonPositive\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"ContractLocked\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"EnforcedPause\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"ExpectedPause\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InputTokenNotMatchRouteFromToken\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InsufficientETH\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InsufficientToken\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InsufficientWETH\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InvalidFeePercentage\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InvalidFeeRecipient\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"InvalidInitCodeHash\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"MinReturnNotReached\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"NonZeroNativeToken\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"owner\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"OwnableInvalidOwner\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"account\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"OwnableUnauthorizedAccount\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"PathWeightInvalid\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"RoutesLengthNotMatchRoutesAmountLength\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"value\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"SafeCastOverflowedUintToInt\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"TransactionDeadlinePassed\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"UNIV2_STYLED_ADAPTER_INSUFFICIENT_LIQUIDITY\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"V3InvalidCaller\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"ZeroAddress\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"ZeroAmount\\\",\\\"type\\\":\\\"error\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"ZeroNativeToken\\\",\\\"type\\\":\\\"error\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"adapter\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"internalType\\\":\\\"bool\\\",\\\"name\\\":\\\"whitelisted\\\",\\\"type\\\":\\\"bool\\\"}],\\\"name\\\":\\\"AdapterWhitelisted\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":false,\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"feeAmount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"recipient\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"FeeRecord\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"inputToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"outputToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"sender\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":false,\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"inputAmount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"indexed\\\":false,\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"outputAmount\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"OrderRecord\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":true,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"previousOwner\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":true,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"newOwner\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"OwnershipTransferStarted\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":true,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"previousOwner\\\",\\\"type\\\":\\\"address\\\"},{\\\"indexed\\\":true,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"newOwner\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"OwnershipTransferred\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"account\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"Paused\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":false,\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"id\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"SwapOrderId\\\",\\\"type\\\":\\\"event\\\"},{\\\"anonymous\\\":false,\\\"inputs\\\":[{\\\"indexed\\\":false,\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"account\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"Unpaused\\\",\\\"type\\\":\\\"event\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"WETH9\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"contract IWETH9\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"address\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"acceptOwnership\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"isAdapterWhitelisted\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"bool\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"bool\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"owner\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"address\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"int256\\\",\\\"name\\\":\\\"amount0Delta\\\",\\\"type\\\":\\\"int256\\\"},{\\\"internalType\\\":\\\"int256\\\",\\\"name\\\":\\\"amount1Delta\\\",\\\"type\\\":\\\"int256\\\"},{\\\"internalType\\\":\\\"bytes\\\",\\\"name\\\":\\\"_data\\\",\\\"type\\\":\\\"bytes\\\"}],\\\"name\\\":\\\"pancakeV3SwapCallback\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"pause\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"paused\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"bool\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"bool\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"pendingOwner\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"\\\",\\\"type\\\":\\\"address\\\"}],\\\"stateMutability\\\":\\\"view\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"renounceOwnership\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"orderId\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"components\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"inputToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"outputToken\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"minOutputAmount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"deadline\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"internalType\\\":\\\"struct IAggregator.BaseExactInRequest\\\",\\\"name\\\":\\\"request\\\",\\\"type\\\":\\\"tuple\\\"},{\\\"internalType\\\":\\\"uint256[]\\\",\\\"name\\\":\\\"routesAmount\\\",\\\"type\\\":\\\"uint256[]\\\"},{\\\"components\\\":[{\\\"internalType\\\":\\\"uint256[]\\\",\\\"name\\\":\\\"mixAdapters\\\",\\\"type\\\":\\\"uint256[]\\\"},{\\\"internalType\\\":\\\"address[]\\\",\\\"name\\\":\\\"assetTo\\\",\\\"type\\\":\\\"address[]\\\"},{\\\"internalType\\\":\\\"uint256[]\\\",\\\"name\\\":\\\"rawData\\\",\\\"type\\\":\\\"uint256[]\\\"},{\\\"internalType\\\":\\\"bytes[]\\\",\\\"name\\\":\\\"extraData\\\",\\\"type\\\":\\\"bytes[]\\\"},{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"fromToken\\\",\\\"type\\\":\\\"address\\\"}],\\\"internalType\\\":\\\"struct IAggregator.RouterPath[][]\\\",\\\"name\\\":\\\"routes\\\",\\\"type\\\":\\\"tuple[][]\\\"},{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"feeConfig\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"swapExactIn\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"outputAmtReceived\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"stateMutability\\\":\\\"payable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"orderId\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"amount\\\",\\\"type\\\":\\\"uint256\\\"},{\\\"internalType\\\":\\\"bool\\\",\\\"name\\\":\\\"isWrap\\\",\\\"type\\\":\\\"bool\\\"},{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"feeConfig\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"swapWrap\\\",\\\"outputs\\\":[{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"outputAmtReceived\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"stateMutability\\\":\\\"payable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"token\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"recipient\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"uint256\\\",\\\"name\\\":\\\"amountMinimum\\\",\\\"type\\\":\\\"uint256\\\"}],\\\"name\\\":\\\"sweep\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"newOwner\\\",\\\"type\\\":\\\"address\\\"}],\\\"name\\\":\\\"transferOwnership\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"int256\\\",\\\"name\\\":\\\"amount0Delta\\\",\\\"type\\\":\\\"int256\\\"},{\\\"internalType\\\":\\\"int256\\\",\\\"name\\\":\\\"amount1Delta\\\",\\\"type\\\":\\\"int256\\\"},{\\\"internalType\\\":\\\"bytes\\\",\\\"name\\\":\\\"_data\\\",\\\"type\\\":\\\"bytes\\\"}],\\\"name\\\":\\\"uniswapV3SwapCallback\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[],\\\"name\\\":\\\"unpause\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"inputs\\\":[{\\\"internalType\\\":\\\"address\\\",\\\"name\\\":\\\"adapter\\\",\\\"type\\\":\\\"address\\\"},{\\\"internalType\\\":\\\"bool\\\",\\\"name\\\":\\\"whitelisted\\\",\\\"type\\\":\\\"bool\\\"}],\\\"name\\\":\\\"whitelistAdapter\\\",\\\"outputs\\\":[],\\\"stateMutability\\\":\\\"nonpayable\\\",\\\"type\\\":\\\"function\\\"},{\\\"stateMutability\\\":\\\"payable\\\",\\\"type\\\":\\\"receive\\\"}]\",\"ContractName\":\"Aggregator\",\"CompilerVersion\":\"v0.8.26+commit.8a97fa7a\",\"OptimizationUsed\":1,\"Runs\":100000,\"ConstructorArguments\":\"0x\",\"EVMVersion\":\"cancun\",\"Library\":\"\",\"LicenseType\":\"\",\"Proxy\":0,\"SwarmSource\":\"\"}]""#);
        Ok(nil)
    }
}
